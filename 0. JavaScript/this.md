# this
> 카일 심슨 - YOU DON'T KNOW JS (this와 객체 프로토타입, 비동기와 성능) 책을 읽고 공부한 내용이다.

## 가장 중요한 사실
- `this`는 함수를 호출한 시점에 바인딩 된다. 그래서 `this`가 무엇을 가리킬지는 **함수를 호출한 코드**에 달렸다.
- 고로 `this`는 함수 자신이나 함수의 렉시컬 스코프를 가리키는 레퍼런스가 아니다.
- **'함수가 어떻게 호출됐는가'** 가 제일 중요하다고!<br/><br/>


## 호출부에 따른 4가지 규칙
1. 기본 바인딩(단독 함수 실행)
    ```javascript
    function foo() {
      console.log(this.a);
    }
    var a = 2;
    foo(); // 2
    ```
    `foo()` 함수의 호출부를 보면 그냥 평범한 기본 함수 호출이다. 기본 바인딩이 적용되어 `this`는 전역 객체를 참조한다. `strict` 모드에서는 전역 객체가 기본 바인딩 대상에서 제외되어, `this`가 `undefined`가 된다.<br/><br/>

2. 암시적 바인딩

    호출부에 콘텍스트 객체가 있는지 확인한다.
    ```javascript
    function foo() {
      console.log(this.a);
    }
    var obj = {
      a: 2,
      foo: foo
    }
    obj.foo(); // 2
    ```
    `foo` 함수가 호출될 시점에 `obj` 객체가 존재하고 있고, **암시적 바인딩** 규칙에 의해 이 `obj`객체(콘텍스트 객체)가 함수 호출 시 `this`에 바인딩 된다.<br/><br/>

3. 명시적 바인딩

    그렇다면 내가 코드상으로 명확하게 어떤 객체를 `this`로 바인딩하겠다는 의지를 나타낼 수는 없을까?
    - `call()`, `apply()` 메서드 사용한다.
    - `this`에 바인딩할 객체를 첫번째 인자로 받아서 함수 호출 시에 해당 객체를 `this`로 세팅한다. -> 객체 직접 바인딩!<br/><br/>


4. new 바인딩
    ```javascript
    function foo(a) {
      this.a = a;
    }
    var bar = new foo(2);
    console.log(bar.a); // 2
    ```
    - 앞에 `new`를 붙여서 `foo()`를 호출했고 새로 생성된 객체는 `foo` 호출 시 `this`에 바인딩 된다.
    - `new`는 함수 호출 시 `this`를 새 객체와 바인딩하는 방법<br/><br/>


총 이렇게 4가지 방법으로 `this` 바인딩을 할 수 있다.

## 예외
1. 화살표 함수(ES6)
    - `this`를 어휘적으로 포착한다.
    - 렉시컬 스코프로 `this`를 바인딩한다.
      
## 정리
- `this` 바인딩은 함수 호출부에 따라 달라진다.
- 이 호출부 식별 후 다음 4가지 규칙에 의해 `this` 바인딩이 적용된다.

1. `new`로 호출했다면 새로 생성된 객체로 바인딩 된다.
2. `call`, `apply`, `bind`로 호출됐다면 주어진 객체롤 바인딩 된다.
3. 호출의 주체인 콘텍스트 객체로 호출됐다면 바로 이 콘텍스트 객체로 바인딩 된다.
4. 기본 바인딩에서 엄격 모드는 기본 전역 객체로 바인딩 되지 않아 `undefined`가 되며, 그 밖엔 전역 객체로 바인딩 된다.