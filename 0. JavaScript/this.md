# this
> 카일 심슨 - YOU DON'T KNOW JS (this와 객체 프로토타입, 비동기와 성능) 책을 읽고 공부한 내용이다.

## 가장 중요한 사실
- `this`는 함수를 호출한 시점에 바인딩 된다. 그래서 `this`가 무엇을 가리킬지는 **함수를 호출한 코드**에 달렸다.
- 고로 `this`는 함수 자신이나 함수의 렉시컬 스코프를 가리키는 레퍼런스가 아니다.
- **'함수가 어떻게 호출됐는가'** 가 제일 중요하다고!

## 호출부에 따른 4가지 규칙
1. 기본 바인딩(단독 함수 실행)
  ```
  function foo() {
    console.log(this.a);
  }
  var a = 2;
  foo(); // 2
  ```
  `foo()` 함수의 호출부를 보면 그냥 평범한 기본 함수 호출이다. 기본 바인딩이 적용되어 `this`는 전역 객체를 참조한다. `strict` 모드에서는 전역 객체가 기본 바인딩 대상에서 제외되어, `this`가 `undefined`가 된다.

2. 암시적 바인딩

호출부에 콘텍스트 객체가 있는지 확인한다.
```
function foo() {
  console.log(this.a);
}
var obj = {
  a: 2,
  foo: foo
}
obj.foo(); // 2
```
`foo` 함수가 호출될 시점에 `obj` 객체가 존재하고 있고, **암시적 바인딩** 규칙에 의해 이 `obj`객체(콘텍스트 객체)가 함수 호출 시 `this`에 바인딩 된다.

3. 명시적 바인딩

그렇다면 내가 코드상으로 명확하게 어떤 객체를 `this`로 바인딩하겠다는 의지를 나타낼 수는 없을까?
- `call()`, `apply()` 메서드 사용한다.
- `this`에 바인딩할 객체를 첫번째 인자로 받아서 함수 호출 시에 해당 객체를 `this`로 세팅한다. -> 객체 직접 바인딩!

